<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>JavaScript Documentation</title>
</head>

<body>

    <nav id="navbar">
        <header>JavaScript Documentation
            <ul>
                <li><a href="#basics_1" class="nav-link">Introduction</a></li>
                <li><a href="#OOP_2" class="nav-link">Object Oriented Programming</a></li>
                <li><a href="#DOM_3" class="nav-link">Document Object Model</a></li>
                <li><a href="#ES6_4" class="nav-link">ECMAScript</a></li>
                <li><a href="#Async_5" class="nav-link">Asynchronous</a></li>
            </ul>
        </header>
    </nav>
    <main id="main-doc">
        <section class="main-section" id="basics_1">
            <header>
                <h1>Fundamentals for JavaScript
                    <h1 />
                    <header>What you should already know</header>
                    <article>
                        <p>This guide assumes you have the following basic background:</p>

                        <ul>
                            <li>
                                A general understanding of the Internet and the World Wide Web (WWW).
                            </li>
                            <li>Good working knowledge of HyperText Markup Language (HTML).</li>
                            <li>
                                Some programming experience. If you are new to programming, try one of
                                the tutorials linked on the main page about JavaScript.
                            </li>
                        </ul>
                    </article>
                    <article>
                        <p>JavaScript is a cross-platform, object-oriented scripting language. It
                            is a small and lightweight language. Inside a host environment (for
                            example, a web browser), JavaScript can be connected to the objects of
                            its environment to provide programmatic control over them.</p>
                        <p>
                            JavaScript contains a standard library of objects, such as Array, Date,
                            and Math, and a core set of language elements such as operators, control
                            structures, and statements. Core JavaScript can be extended for a
                            variety of purposes by supplementing it with additional objects;
                        </p>
                        <p> Who created JavaScript ?<br>
                            JavaScript was created by Brendan Eich in 1995 during his time at Netscape Communications.
                            Initially it was developed under developed under the name Mocha, but later the language was
                            officially called LiveScript when it first shipped in beta releases of Netscape.
                        </p>
                        <p>
                            What is JSON and syntax rules of JSON ?<br>
                            JSON (JavaScript Object Notation) is lightweight format that is used for data interchanging.
                            It based on a subset of JavaScript language in the way objects are built in JavaScript.<br>
                            The syntax rules of JSON:
                            <li>The data is in name/value pairs</li>
                            <li>The data is separated by commas</li>
                            <li>Curly braces hold objects</li>
                            <li>Square brackets hold arrays</li>
                        </p>

                        <p>What is the purpose of JSON stringify ? <br>
                            When sending data to a web server, the data has to be in a string format.
                            You can achieve this by converting JSON object into a string using stringify() method.<br>
                            <pre>
                                <code>
                                    var userJSON = {'name': 'John', age: 32}
                                    var userString = JSON.stringify(userJSON);
                                    console.log(userString); // returns "{"name":"John", "age": 32}"
                                </code>
                            </pre>
                        </p>

                        <p>How do you parse JSON string ?<br>
                            When receiving the data from a web server, the data is always in a string format.
                            But you can convert this string value to a javascript object using parse() method.<br>
                            <pre>
                                <code>
                                    var userString = '{"name":"John", "age": 31}';
                                    var userJSON = JSON.parse(userString);
                                    console.log(userJSON); // {name: "JSON", age: 13}
                                </code>
                            </pre>
                        </p>
                        <p>What is a Regular Expression ?<br>
                            A Regular expression is a sequence of characters that forms a search pattern.
                            You can use this search pattern for searching data in a text. These can be used to
                            perform all types of text search and text replace operations. Let's see the syntax format
                            now,
                        </p><br>
                        <p>What are the string methods available in regular expressions ?<br>
                            Regular expressions has two string methods: search() and replace().
                            The search() method uses an expression to search for a match, and returns the positions of
                            the match.<br>
                            <pre>
                                <code>
                                    var msg = "Hello John";
                                    var n = msg.search(/John/i); // 6

                                </code>
                            </pre>
                        </p>

                        <p>What are Events ?<br>

                            Events are "things" that happen to HTML elements.
                            When JavaScript is used in HTML pages, JavaScript
                            can react on these events.
                            Some of the examples of HTML events are,
                            <li>Web page has finished loading</li>
                            <li>Input field was changed</li>
                            <li>Button was clicked</li><br>
                            Let's describe the behavior of click event for buttons elements.<br>
                            <pre>
                                <code>
                                    function greeting() {
                                    alert( 'Hello! Good morning' );
                                    }
                                </code>
                            </pre>
                            <script>
                                function greeting() {
                                    alert( 'Hello! Good morning' );
                                }
                            </script>
                            </head>

                            <body>
                                <button type="button" onclick="greeting()">Click me to Understand Alert</button>
                            </body>



                        </p>
                        <p>What is the use of preventDefault method ?<br>
                            The preventDefault() method cancels the event if it is cancelable, meaning that the default
                            actions that belongs to the event will not occur. For example, prevent form
                            submission when clicking on submit button and prevent opening the page URL when clicking on
                            hyperlink are some common use cases.
                        </p>


                        <p>What are closures ? <br>
                            A closure is the combination pf a function and the lexical
                            environment within which the function was declared,
                            i.e, It is an inner function that has access to the outer or enclosing function’s variables.
                            The closure has three scope chains

                            <li>Own scope where variables are defined between its curly brackets</li>
                            <li>Outer function's variables</li>
                            <li>Global variables</li>
                        </p>

                    </article>
            </header>
        </section>
        <section class="main-section">
            <header id="OOP_2">
                <h1>Object Oriented Concepts</h1>
            </header>
            <article>
                <h3>Object-oriented programming — the basics</h3>
                <p>
                    The basic idea of OOP is that we use objects to model real world things that we want to represent
                    inside our programs, and/or provide a simple way to access functionality that would otherwise be
                    hard or impossible to make use of.

                    Objects can contain related data and code, which represent information about the thing you are
                    trying to model, and functionality or behavior that you want it to have. Object data (and often,
                    functions too) can be stored neatly (the official word is encapsulated) inside an object package
                    (which can be given a specific name to refer to, which is sometimes called a namespace), making it
                    easy to structure and access; objects are also commonly used as data stores that can be easily sent
                    across the network.
                </p>
                <h3>What are the possible ways to create objects in JavaScript</h3>
                <p>There are many ways to create objects in JavaScript

                    The simplest way to create an empty object is using the Object constructor. Currently this approach
                    is not recommended.<br>
                    <li>Object constructor</li>
                </p>
                <code>var object = new Object();
                </code>

                <p>
                    <li>Object literal syntax</li>
                    The object literal syntax is equivalent to create method when it passes null as parameter
                </p>
                <code>var object = {};
                </code>

                <p>
                    <li>Function constructor</li>
                    Create any function and apply the new operator to create object instances,
                </p>
                <pre>
                <code>function Person(name){
        var object = {};
        object.name=name;
        object.age=21;
        return object;
        }
        var object = new Person("Souha");
        var object = new Person("Roshan");</code>
                    </pre>
                <p>
                    <li>Function constructor with prototype</li>
                    This is similar to function constructor but it uses prototype for their properties and methods,
                    This is equivalent to an instance created with an object create method with a function prototype and
                    then call that function with an instance and parameters as arguments.
                    <pre>
                        <code>function Person(){
        Person.prototype.name = "Sudheer";
        var object = new Person();
        }
                        </code>
                    </pre>
                </p>

                <p>
                    <li>ES6 Class syntax</li>
                    ES6 introduces class feature to create the objects
                    <pre>
                        <code>class Person {
        constructor(name) {
        this.name = name;
        }
        }

        var object = new Person("Sudheer");
                        </code>
                    </pre>
                </p>

                <p>
                    <li>Singleton Pattern</li>
                    A Singleton is an object which can only be instantiated one time. Repeated calls to its constructor
                    return the same instance and this way one can ensure that they don't accidentally create multiple
                    instances.
                    <pre>
                        <code>var object = new function(){
            this.name = "Sudheer";
            }

                        </code>
                    </pre>
                </p>
            </article>
        </section>

        <section class="main-section">
            <header id="DOM_3">
                <h1>Document Object Model</h1>
            </header>
            <img
                src="https://res.cloudinary.com/practicaldev/image/fetch/s--RVmdeWUQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://i.imgur.com/NoaU9WT.png">
            <article>
                <p>
                    JavaScript has many abilities, one of the most useful of them is its ability to manipulate the DOM.
                    Although what exactly is DOM and how we can change it?
                </p>
                <h3>What is the relation between DOM and webpage?</h3>
                <p>DOM stands for Document Object Model and it's a tree-like representation on a webpage or document.
                    Let's say each node has a relationship with other nodes and that's depending on how they are
                    arranged in the HTML document. Here's some simple HTML code:
                    We frequently referring to the parts of DOM with family relations, for example on the previous image
                    the --html-- tag is
                    the parent of the

                    --head-- and the

                    --body--. The li elements are the children of the --ul-- element. Similarly, the --li-- are sibling
                    elements.

                    Your HTML it's a template which when a browser reads it, it creates the DOM.

                    When you are creating a site you might want to play with the DOM and be able to
                    change in response to a
                    user action.Every web framework provides a way to adjust the DOM but for start we'll
                    stick with plain
                    JavaScript or, even better, jQuery!
                </p>
                <p><b>Important note:</b><br>
                    Usually your JavaScript, is run when the JS file is run, or when the script tag is encountered in
                    the HTML. So if you are including your script tag at the top of your file, many of your methods will
                    not work because the JS code will run before the elements you want to manipulate are created. A
                    simple way to fix this problem is to include your script tags at the bottom of your html, so that it
                    gets run after the elements/nodes are created.
                </p>
            </article>

        </section>
        <section class="main-section">
            <header id="ES6_4">
                <h1>ECMAScript(ES6)</h1>
                <article>
                    <p>What is ECMAScript ?<br>
                        ECMAScript is the scripting language that forms basis of JavaScript.
                        ECMAScript standardized by the ECMA international standards organization
                        in the ECMA-262 and ECMA-402 specifications. The first edition of ECMAScript
                        was released in 1997.
                    </p>

                    <h3>Let and Const</h3>
                    <p>
                        let: mutable variables, means we can reassign its value. let can be declared without being
                        initialized.

                        const: immutable variables, means we cannot reassign value to const variables. const must be
                        initialized during declaration.

                        Both of them are block-scope variables, which means it is only available within the block where
                        the variable is declared.<br>
                        <b>TakeAways</b>
                        t is recommended to use let and const than using var, because when we use let and const will be
                        hoisted to the top but they are not initialized (unlike var that has been initialized with the
                        value of undefined) and this helps us to get better error message. Furthermore, we can't
                        iniatialized those variables before we declare them. This is useful to make sure that our
                        variables has been declared before we can use them and this is a good practice in programming.

                        <pre>
                        <code>// traditional
var x = 5;
y = 8;
var y;

console.log(x); // 5
console.log(y); // 8

// es6
let i = 10;
j = 15;
let j;
console.log(i); //10
console.log(j); 
// Error: Cannot access 'j' before initialization

const k = 29;
k = 39;
console.log(k); 
// Error: Assignment to constant variable.

let m;
m = 'hello';

const n;
n = 'goodbye';
console.log(m); 
// hello
console.log(n); 
// Error: Missing initializer in const declaration


                        </code>
                    </pre>

                    </p>

                    <h3>Arrow Functions</h3>
                    <p>Let's begin by showing you how to write function in traditional syntax vs ES6 syntax.
                        <pre>
<code>
// traditional
var sum = function (a, b) {
    return a + b;
}

// es6
const sum = (a, b) => a + b;

</code>
                    </pre>
                        t's really awesome, right?
                        The arrow function makes your code looks clean, more structured and more readable.

                        When the body inside arrow function has more than one line, we need to wrap it inside {}.

                        <pre>
<code>
const sum = (a, b) => {
    const result = a + b;
    return result;
}

</code>
                    </pre>
                        Arrow function commonly used as callbacks. You will find it a lot when working with map(),
                        filter()
                        and reduce().
                        <pre>
    <code>
// traditional
const arr1 = [1,3,5];
const square1 = arr1.map(function(item) {
return item ** 2;
});
console.log(square1); // [1, 9, 25]


// es6
const arr2 = [1,3,5];
const square2 = arr2.map(item => item ** 2);
console.log(square2);
    </code>
</pre>
                        Although it is a powerful addition in ES6 but there are limitations that we need to understand
                        to avoid errors that are
                        difficult to track, such as when using this inside arrow function.

                        On the car2 example, the result might be something that you are not looking for. So, we need to
                        be careful when using
                        arrow function. This happens because arrow function doesn’t have its own bindings to this,
                        instead they inherit from
                        parent scope, which is called lexical scoping.

                    </p>

                    <h3>Template literals</h3>
                    <p>
                        Template literals or template strings is a new way to concatenate strings in ES6.
                        Let's take a look at code example below.

                        This is how we create greetings function that will greet the given name in traditional syntax.
                        <pre>
    <code>
// es6
const greetings = (name) => `hello ${name}`;
console.log(greetings('Muhammad Roshan')); // 'hello Muhammad Roshan'

    </code>
</pre>
                        With template literals, our code looks more structured. We don't need the + sign anymore and we
                        can use ${} to call
                        variables.
                    </p>
                    <h3>Default Parameters</h3>
                    <p>
                        In ES6, we can give default value to function's parameters.

                        With the old syntax, this is how we create default value to a parameter.
                    </p>
                    <pre>
<code>
const sayGoodbye = (name = ‘Lorem Ipsum’ ) => `Bye bye ${name}`
console.log(sayGoodbye()); // Bye bye Lorem Ipsum
console.log(sayGoodbye(‘Bambang’)); // Bye bye Bambang
</code>
                    </pre>
                    It's so simple and easy to understand. This also helps you to handle error in advance when you
                    forget to assign the
                    parameter.

                </article>
            </header>

        </section>
        <section class="main-section">
            <header id="Async_5">
                <h1>Async / Await Code</h1>
            </header>
            <p>
                Promise and Async/await is something that you will hear often and I thought this is one of scariest
                things in Javascript. Until I understand how it works. By writing this article, I don’t promise (no pun
                intended) this will be easy to understand but hopefully you might gain something here in understanding
                Asynchronous Javascript.

                Now, let’s move on to the main topic!

                Although javascript is a synchronous, blocking, single-threaded language which means it can only run one
                operation at a time, recently, Javascript has provide us ways to run our code asynchronously. This means
                we can let our code do several things without blocking the main thread.

                Before we jump to the technical concept, we need to understand asynchronous actions first. In simple
                terms, asynchronous action is an action that we start now and finish later. In Javascript, we do
                asynchronous actions when we are doing network requests or fetching data, for example.
            </p>

            <h3>callback</h3>
            <p>
                Now, let's create a simple network request from API using XHR. We also have added callback to make it
                reusable for handling error message
                <pre>
<code>
    const getTodo = (resource, callback) => {
    const request = new XMLHttpRequest();
    request.addEventListener("readystatechange", () => {
    // this event is fired when the readyState attribute of a document has changed
    // we will return the callback when it finished and throw and error if it's an unsuccessful
    request
    if (request.readyState === DONE && request.status === 200) {
    callback(undefined, request.responseText);
    } else if (request.readyState === DONE) {
    // if it's done fetching but error request status is unsuccessful
    // such as typo in request URL
    callback("could not fetch data", undefined);
    }
    });

    request.open("GET", resource);
    request.send();
    };

    console.log("1");
    console.log("2");
    getTodo("https://jsonplaceholder.typicode.com/todos/1", (err, data) => {
    if (err) {
    console.log(err);
    } else {
    console.log("success:", data);
    }
    });
    console.log("3");
    console.log("4");
    console.log("5");
</code>
                </pre>
                Callback is a function that runs after an action is finished. In this example, our callback will give us
                error message when data fetching is failed or give us the data we requested if it's successful.
            </p>

            <h3>Callback Hell</h3>
            <p>
                After we received the response, sometimes we will need to use the data to make another requests. Now,
                let's try to chain multiple sequential requests using our code.
                <pre>
<code>
    const getTodo = (resource, callback) => {
    const request = new XMLHttpRequest();
    request.addEventListener("readystatechange", () => {
    // this event is fired when the readyState attribute of a document has changed
    // we will return the callback when it finished and throw and error if it's an unsuccessful request
    if (request.readyState === DONE && request.status === 200) {
    const data = JSON.parse(request.responseText);
    callback(undefined, data);
    } else if (request.readyState === DONE) {
    // if it's done fetching but error request status is unsuccessful
    // such as typo in request URL
    callback("could not fetch data", undefined);
    }
    });

    request.open("GET", resource);
    request.send();
    };

    // this is how we chain network request
    getTodo("https://jsonplaceholder.typicode.com/todos/1", (err, data) => {
    console.log("request 1", data);
    getTodo("https://jsonplaceholder.typicode.com/todos/2", (err, data) => {
    console.log("request 2", data);
    getTodo("https://jsonplaceholder.typicode.com/todos/3", (err, data) => {
    console.log("request 3:", data);
    })
    })
    });

</code>
            </pre>
            </p>

            <h3>Promise</h3>
            <p>
                In Javascript, Promise means doing something that takes time then produces a result, just like
                real-world promise.

                After a Promise takes the time needed to produce the promised result, it will either resolve when it’s
                fulfilled or reject when there is an error. If it’s resolved, we can get access to the returned data and
                if it’s rejected, we can throw an error.

                In this example, we want to create a network request from API that returns either a resolved Promise
                when it's succeed or a rejected Promise when we couldn't get the data.

                <pre>
<code>
const getTodo = (resource) => {
    return new Promise((resolve, reject) => {
        const request = new XMLHttpRequest();

        request.addEventListener("readystatechange", () => {
            if (request.readyState === 4 && request.status === 200) {
                const data = JSON.parse(request.responseText);
                resolve(data);
            } else if (request.readyState === 4) {
               reject("error getting resource");
            }
        });

        request.open("GET", resource);
        request.send();
      });
    };

    getTodo("https://jsonplaceholder.typicode.com/todos/1")
    .then(data => {
    console.log("promise resolved:", data);
    }).catch(err => {
    console.log("promise rejected:", err)
    });
</code>
                </pre>
                Promise is a part of Asynchronous Javascript, a technique that allows us to create an action that we
                start now and finish later, which means we can let our code do several things without blocking the main
                thread.
            </p>

            <h3>Chaining Promises</h3>
            <p> Now what if we want to create sequential network requests that might have dependencies to the previous
                response? The answer is, we can chain our requests!
                <pre>
<code>
    const getTodo = (resource) => {
    return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();

    request.addEventListener("readystatechange", () => {
    if (request.readyState === 4 && request.status === 200) {
    const data = JSON.parse(request.responseText);
    resolve(data);
    } else if (request.readyState === 4) {
    reject("error getting resource");
    }
    });

    request.open("GET", resource);
    request.send();
    });
    };

    console.log('1')
    console.log('2')
    getTodo("https://jsonplaceholder.typicode.com/todos/1")
    .then((data) => {
    console.log("promise 1 resolved:", data);
    return getTodo("https://jsonplaceholder.typicode.com/todos/2");
    })
    .then((data) => {
    console.log("promised 2 resolved:", data);
    return getTodo("https://jsonplaceholder.typicode.com/todos/3");
    })
    .then(data => {
    console.log("promised 3 resolved:", data);
    })
    .catch((err) => {
    console.log("promise rejected:", err);
    });
    console.log('3')
    console.log('4')

</code>
                </pre>
                Because then() returns a Promise, we can easily chain our requests with another then().

                We also have catch() that will throw an error for any unsuccessful then(), so we don't need to throw an
                error for each request, which means when the first request return error, it will not go to the second
                request. The next request will only fire if the previous Promise has been resolved
            </p>
            <h3>Fetch API</h3>
            <p>With Fetch API the Promise will get rejected if there is any network error or we can't reach the api for
                some reason.

                When using Fetch, we need to remember 3 things:

                Fetch the data
                Then we take the response and returns response.json() that returns a Promise
                Then we can use then() to fire a function where we can have access to that data
                In this example, we want to refactor our getTodo code with Fetch API to create the network request,
                instead of XHR.
                <pre>
<code>
    const getTodoFetch = () => {
    fetch("https://jsonplaceholder.typicode.com/posts/1")
    .then((response) => {
    // if there is a typo on the request url, it will still get resolved so we need to check the status
    if (!response.ok) {
    return Promise.reject("there is an error fetching the data");
    }
    console.log("status ok", response);
    return response.json(); // returns a Promise
    })
    .then((data) => {
    console.log("resolved:", data);
    })
    .catch((err) => {
    console.log("rejected:", err);
    });
    };
    getTodoFetch();
</code>
            </pre>
            </p>

            <h3>Async/await</h3>
            <p>
                Finally, we have reached the long awaited part. First, let me remind you the concept of asynchronous,
                which is start now finish later. Now, we will create a async/await request using Fetch.
                <pre>
<code>
    const getTodoAsyncAwait = async (resource) => {
    const response = await fetch(resource);
    const data = await response.json();

    if (!response.ok) {
    // we can throw error using Error object, so it will rejected by the Promise
    // and pass our error message
    throw new Error("cannot fetch data");
    }

    return data;
    };
    getTodoAsyncAwait("https://jsonplaceholder.typicode.com/todos/1")
    .then(data => console.log('resolved:', data))
    .catch(err => console.log('rejected:', err.message));
</code>
                </pre>
                Any function with the async keyword will return a Promise. Inside an async function, there is no need to
                do then().

                Because we put await inside async function, it will not render-block the whole app. It just blocked
                inside its own async function code block.
            </p>

        </section>
        <section class="main-section" id="Reference">
            <header>Reference</header>
            <article>
                <ul>
                    <li>
                        All the documentation in this page is taken from
                        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide" target="_blank">MDN</a>
                    </li>
                </ul>
            </article>
        </section>


    </main>


    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    <script src="./app.js"></script>
</body>

</html>